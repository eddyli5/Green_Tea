虽然JavaScript语言中并没有用于私有成员的特殊语法，但是可以使用闭包来实现这种功能。
构造函数创建一个闭包，而在闭包范围内部的任意变量都不会暴露给构造函数以外的代码。
然而这些私有变量仍然可以用于公共方法中：即定义在构造函数中，且作为返回对象的一个部分暴露给外部的方法。

Privileged_Method，特权方法是指那些访问私有成员的公共方法的一个名称而已。

private_invalid，私有性失效主要有两种情况：
1、一些边缘情况：如Mozilla Rhino中的__parent__属性能够访问函数的私有作用域。
2、直接从一个特权方法中返回一个私有变量，且该变量恰好是一个对象或者数组，那么外面的代码仍然可以访问该私有变量，因为它是通过引用传递的。

在私有性失效的时候有两种解决方案：
1、最低授权原则(POLA，Principle of Least Authority)，规定应该永远不要给予超过需要的特权。即不要分发所有的数据，仅返回需要的数据的新对象。private_POLA
2、当需要传递所有数据时，另外一种解决方法使用一个通用性的对象克隆(object_cloning)函数以创建对象的副本。如著名的extend().private_cloning。

对象字面量(object_literal)的私有性如何保证？可以使用一个额外的匿名即时函数(anonymous immediate function)创建闭包来实现私有性。private_literal

私有性与原型：当将私有成员与构造函数在一起使用时，其中的一个缺点在于每次调用构造函数以创建对象时，这些私有成员都会被重新创建。
为了避免复制工作以及节省内存，可以将常用的属性和方法添中到构造函数的prototype属性中。
这样，通过同一个构造函数创建的多个实例可以共享常见的部分数据。
此外，还可以在多个实例中共享隐藏的私有成员。（此处要格外小心，因为是传值，所以每个实例的改动都会影响其它实例）
为了实现这一点：可以使用 构造函数的私有成员 和 对象字面量中的私有属性 两个模式。private_prototype

揭示模式(revelation pattern)可用于将私有方法暴露成为公共方法。当为了对象的运转而将所有功能放置在一个对象中以及想尽可能地保护对象是至关重要的时候，这种揭示模式就显得非常有用。private_revelation_pattern