我们应该尽量避免使用class这个单词，而将其表述为构造函数(constructor function 或 constructor)。
这种表述更为精确且不会产生歧义。

//父构造函数
function Parent (name) {
	this.name = name || 'Adam';
}
//向该原型添加功能
Parent.prototype.say = function () {
	return this.name;
};
//空白的子构造函数
function Child (name) {
	
}


//继承的实现,我们需要搞定的功能
inherit(Child,Parent);


默认模式：(inherit_default)采用原型链追溯的形式。
这个模式的缺点：
1、同时继承了两个对象的属性，即添加到this的属性以及原型属性。绝大多数情况下，并不需要这些自身的属性，因为它们很可能是指向一个特定的实例，而不是复用。
对于构造函数的一般经验法则是：应该将可复用的成员添加到原型中
2、使用通用inherit()函数并不支持参数传递到子构造函数中。虽然子构造函数可以将参数传递到父构造函数中。但是那样的话，效率将会低下，因为最终会反复地重新创建对象。

借用构造函数：(rent_constructor)借用父构造函数，传递子对象以绑定到this，并且还转发任意参数。
在这种方式中，只能继承在父构造函数中添加到this的属性。但并不能继承那些已添加到原型中的成员
该模式的优点：可以获得父对象自身成员的真实副本，并且也不会存在子对象意外覆盖父对象属性的风险
缺点也非常明显：无法从原型中继承任何东西，并且原型也仅是添加可重用方法以及属性的位置，它并不会为每个实例重新创建原型。

组合继承：(combination_inheritance),有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合在一起，即先借用构造函数，然后再设置子构造函数的原型使其指向一个构造函数创建的新实例。从而发挥二者之长的一种继承模式。这种方式最接近class继承语言的实现方式.
但这种方式的缺点是：将会两次调用父构造函数。

共享原型：(share_prototype)，不需要两次调用父构造函数。
该模式的经验法则是：可复用成员应该转移到原型中而不是放置在this中。因此，出于继承的目的，任何值得继承的东西都应该放置在原型中实现。
所以，仅将子对象的原型与父对象的原型设置为相同的即可。
但这种模式的缺点是：处于继承链下方的子对象修改了原型，它将会影响所有的父对象和祖先对象。



道格拉斯.克罗克福德(Douglass Crockford)在2006年写了一篇文章，题为Prototypal Inheritance in JavaScript。在这篇文章中，他介绍了一种实现继承的方法，这种方式并没有使用严格意义上的构造函数。
原型式继承：(prototype_pattern)，借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。
在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。
不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。

寄生式继承：(inherit_parasitic)采用与原型式继承紧密相关的一种思路，并且同样由克罗克福德推而广之。
寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。
在主要考虑对象而不是自定义函数和构造函数的情况下，寄生式继承是一种有用的模式。
寄生式继承可以为对象添加函数，会由于不能做到函数复用而降低效率

寄生组合式继承：(combination_parasitic) 可以用来解决组合继承两次调用父构造函数的问题。
通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。不必为了指定子类型的原型而调用超类型的构造函数，我们所需无非就是超类型原型的一个副本而已。
目前该模式被开发人员普遍认为是最理想的继承范式
YUI的YAHOO.lang.extend()方法采用了寄生组合继承。http://developer.yahoo.com/yui/



临时构造函数(temporary_constructor)，通过断开父对象与子对象的原型之间的直接链接关系，从而解决共享同一个原型所带来的问题，而且同时还能够继承受益于原型链带来的好处。
该模式和原型式继承非常相似，一个是针对父对象，一个是针对父构造函数的原型

圣杯模式：(Holy_Grail)也被认为是适用于项目中的最佳方法。在开源YUI库和其他的一库里还存在一个与本函数相似的函数